import atexit
import os

import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

from adventure.models.adventure import Adventure, AdventureQuota
from app import app
from auth.services.auth_service import create_access_token
from auth.utils.auth_utils import get_password_hash
from core.database import Base, get_db
from user.models.user import User


# Test database setup with worker isolation for pytest-xdist
def get_test_db_url():
    """Get a unique database URL for each test worker"""
    worker_id = os.environ.get("PYTEST_XDIST_WORKER", "master")
    return f"sqlite:///./test_{worker_id}.db"


SQLALCHEMY_DATABASE_URL = get_test_db_url()

engine = create_engine(SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False})
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)


# Clean up test database files on exit
def cleanup_test_db():
    """Clean up test database files"""
    db_file = SQLALCHEMY_DATABASE_URL.replace("sqlite:///./", "")
    if os.path.exists(db_file):
        try:
            os.remove(db_file)
        except OSError:
            # Handle file system errors (permissions, file in use, etc.)
            pass


atexit.register(cleanup_test_db)


@pytest.fixture(scope="function")
def db():
    """Create a test database session with proper cleanup for parallel execution"""
    # Ensure clean slate for each test
    Base.metadata.drop_all(bind=engine)
    Base.metadata.create_all(bind=engine)

    db = TestingSessionLocal()
    try:
        yield db
    finally:
        db.close()
        # Clean up after each test
        Base.metadata.drop_all(bind=engine)


@pytest.fixture(scope="function")
def client(db):
    """Create a test client"""

    def override_get_db():
        try:
            yield db
        finally:
            db.close()

    app.dependency_overrides[get_db] = override_get_db
    with TestClient(app) as c:
        yield c
    app.dependency_overrides.clear()


@pytest.fixture
def test_user(db):
    """Create a test user"""
    user = User(
        email="test@example.com",
        username="testuser",
        password=get_password_hash("testpassword123"),
        is_active=True,
    )
    db.add(user)
    db.commit()
    db.refresh(user)
    return user


@pytest.fixture
def test_user_token(test_user):
    """Create an access token for the test user"""
    return create_access_token(data={"sub": test_user.email})


@pytest.fixture
def auth_headers(test_user_token):
    """Create authentication headers"""
    return {"Authorization": f"Bearer {test_user_token}"}


@pytest.fixture
def test_adventure(db, test_user):
    """Create a test adventure"""
    adventure = Adventure(
        title="Test Adventure",
        description="A test adventure description",
        location="Test Location",
        destination="Test Destination",
        duration="half-day",
        activity_type="hiking",
        is_round_trip=True,
        created_by=test_user.id,
        itinerary=[
            {
                "time": "10:00 AM",
                "activity": "Start hiking",
                "location": "Trailhead",
                "duration": "1 hour",
                "notes": "Bring water",
            }
        ],
        route={
            "start_address": "Test Start",
            "end_address": "Test End",
            "waypoints": [],
            "map_embed_url": "https://maps.google.com/test",
            "estimated_distance": "5 km",
            "estimated_travel_time": "2 hours",
        },
        weather_forecast={
            "temperature": "22°C",
            "conditions": "Sunny",
            "precipitation": "0%",
            "wind": "10 km/h",
            "uv_index": "6",
            "best_time_outdoors": "Morning",
        },
        packing_list={
            "essential": ["Water", "Snacks"],
            "weather_specific": ["Sunscreen"],
            "optional": ["Camera"],
            "food_and_drink": ["Energy bars"],
        },
        recommendations={
            "photo_opportunities": ["Scenic viewpoint"],
            "local_tips": ["Start early"],
            "hidden_gems": ["Secret trail"],
        },
    )
    db.add(adventure)
    db.commit()
    db.refresh(adventure)
    return adventure


@pytest.fixture
def test_adventure_quota(db, test_user):
    """Create a test adventure quota"""
    quota = AdventureQuota(user_id=test_user.id, quota_remaining=5)
    db.add(quota)
    db.commit()
    db.refresh(quota)
    return quota


@pytest.fixture
def mock_openai_response():
    """Mock OpenAI API response for testing"""
    return {
        "title": "Mock Adventure",
        "description": "A mock adventure generated by AI",
        "image_url": "https://example.com/image.jpg",
        "itinerary": [
            {
                "time": "09:00 AM",
                "activity": "Mock Activity",
                "location": "Mock Location",
                "duration": "2 hours",
                "notes": "Mock notes",
            }
        ],
        "route": {
            "start_address": "Mock Start",
            "end_address": "Mock End",
            "waypoints": [],
            "map_embed_url": "https://maps.google.com/mock",
            "estimated_distance": "10 km",
            "estimated_travel_time": "3 hours",
        },
        "weather_forecast": {
            "temperature": "20°C",
            "conditions": "Cloudy",
            "precipitation": "20%",
            "wind": "15 km/h",
            "uv_index": "4",
            "best_time_outdoors": "Afternoon",
        },
        "packing_list": {
            "essential": ["Water", "First aid"],
            "weather_specific": ["Light jacket"],
            "optional": ["Binoculars"],
            "food_and_drink": ["Sandwiches"],
        },
        "recommendations": {
            "photo_opportunities": ["Mountain view"],
            "local_tips": ["Check weather"],
            "hidden_gems": ["Hidden waterfall"],
        },
    }
